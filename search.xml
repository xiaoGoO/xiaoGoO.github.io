<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[007_Shell_运算符]]></title>
    <url>%2F2017%2F01%2F01%2FShell%2F007-Shell-%E8%BF%90%E7%AE%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[运算符 序 shell 支持多种运算符例如： 算术运算符 关系运算符 布尔运算符 字符串运算符 文件测试运算符 原生的bash不支持算数运算符，需要借助其他命令来完成，例如： awk expr(比较常用) expr 格式 1值=`expr 值1 运算符 值2` 注意: 表达式和运算符之间要有空格，例如 2+2 是不对的，必须写成 2 + 2，这与我们熟悉的大多数编程语言不一样。 完整的表达式要被 包含，注意这个字符不是常用的单引号，在 Esc 键下边。 所有运算符 运算符 | 说明 | 例子 — | — | — | 加 | expr 1 + 1 =&gt; 2 | 减 | expr 2 - 1 =&gt; 1 | 乘 | expr 2 \* 2 =&gt; 4/ | 除 | expr 2 / 2 =&gt; 1% | 除余 | expr 2 % 2 =&gt; 0= | 赋值符 | a=$b 就是将变量b的值赋予给变量a== | 判断符，等于 | [ $a == $b ] 判断变量a是否等于变量b,如果相等返回true，否则false!= | 判断符，不等于 | [ $a != $b ] 与 == 相反]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>脚本</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[006_Shell_传参]]></title>
    <url>%2F2017%2F01%2F01%2FShell%2F006-Shell-%E4%BC%A0%E5%8F%82%2F</url>
    <content type="text"><![CDATA[传参 序 我们在开发脚本过程中，少不了会给执行的脚步传递参数 ，就好比我写一个文件复制的脚步，我需要动态传递我需要复制的文件路径和复制后存放的路径，要不然没用一次就改一次代码就太不人性化了。 实例 比我写了个脚本名为：006_shell_params.sh shell123456#获取参数echo &quot;获取执行脚本名称：$0&quot;echo &quot;获取第一个参数：$1&quot;echo &quot;获取第二个参数：$2&quot;echo &quot;参数个数：$#&quot;echo &quot;全部参数：$*&quot; - 执行结果 ![参数结果](http://oiu3bjtd5.bkt.clouddn.com/20180305152021858543372.jpg) 参数处理表 处理 | 说明 — | — $# | 参数个数 $ | 以字符串的方式输出所有参数 , “$“ -&gt; “param0 param1 param2” $@ | 与$相同，但是用 **“*** 号括起来，是以数组形式输出 “$@” -&gt; “param0” “param1” “param2” $! | 运行最后一个进程的ID $- | 显示Shell的当前选项 $? | 显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>脚本</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[005_Shell_注释]]></title>
    <url>%2F2017%2F01%2F01%2FShell%2F005-Shell-%E6%B3%A8%E9%87%8A%2F</url>
    <content type="text"><![CDATA[注释 序 # 号后面的内容都会被注释 注释即脚本运行时不起作用的内容，知用于脚本代码说明。]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>脚本</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[004_Shell_数组]]></title>
    <url>%2F2017%2F01%2F01%2FShell%2F004-Shell-%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[数组 序 只支持一维数组 下标由0开始的数组 数组的定义 一般用括号“()” 来表示数组，每个元素用空格隔开 shell1234567891011121314# 变量名称=(元素0 元素1 元素2 ... 元素n-1)# 定义数组变量的方法有三种# 类型一array=(&quot;小关1号&quot; &quot;小关2号&quot; &quot;小关3号&quot;)#类型二array2=( &quot;小燕1号&quot; &quot;小燕2号&quot; &quot;小燕3号&quot;)#类型三array3[0]=&quot;xiaoG一号&quot;array3[1]=&quot;xiaoG二号&quot;array3[2]=&quot;xiaoG三号&quot; 读取数组 读取数组的格式为 ${数组[下标]} shell12345678910111213array=(&quot;小关1号&quot; &quot;小关2号&quot; &quot;小关3号&quot;)# 读取数组第一个值echo $&#123;array[0]&#125;# 读取数组所有元素echo $&#123;array[@]&#125;# 读取数组长度echo $&#123;#array[@]&#125;#或者echo $&#123;#array[*]&#125;#获取数组第n个元素的长度 echo $&#123;#array[n]&#125;]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>脚本</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[003_Shell_字符串]]></title>
    <url>%2F2017%2F01%2F01%2FShell%2F003-Shell-%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[Shell 字符串 序 shell的数据类型就只有数字和字符串 单引号 作用 单引号里的内容回被原样输出，转义符、变量的作用将会失效。 例子 代码 shell12name=&apos;小关&apos;;echo &apos;我的名字叫$name&apos; 运行效果如下 双引号 作用 双引号里的转义符，变量会生效 例子 代码 shell12name=&apos;小关&apos;;echo &quot;我的名字叫$name&quot; 运行结果如下 拼接 例子 shell1234xiaoG=&quot;小关&quot;;xiaoY=&quot;小燕&quot;;newStr=&quot;$&#123;xiaoG&#125;+$&#123;xiaoY&#125;&quot;echo $newStr &quot;在一起&quot; 运行结果如下 长度 例子 shell123## 获取字符串长度 ###str=&quot;你猜我有多长？&quot;;echo &quot;你的长度是：$&#123;#str&#125;&quot; 运行结果 截取子串 例子 代码，截取子串的范围 ${str:1:2} -&gt; 截取变量 str 从第2个字符串开始截取长度未2 shell123## 截取子字符串 ##str=&quot;你截取“小关”试试看&quot;echo &quot;截取：$&#123;str:4:2&#125;&quot; 运行结果 查找子串的位置 例子 代码，查找子串“小关”的位置 shell1234## 查找子串位置 ##str=&quot;你看看“小关”在哪里？&quot;subStr=&quot;小关&quot;echo `expr index &quot;$str&quot; $subStr` 因为本人使用的事macos 系统，因为 macos系统使用的是BSD expr 不能执行该语句，Linux 使用的是 GNU expr 可以执行该语句]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>脚本</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[002_Shell_变量]]></title>
    <url>%2F2017%2F01%2F01%2FShell%2F002_Shell_%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[基本语法变量 变量命名规则 首个字符必须为字母（a-z，A-Z）。 中间不能有空格，可以使用下划线（_） 不能使用标点符号。 不能使用bash里的关键字（可用help命令查看保留关键字）。 变量的使用 Shell12345678910# 赋值 注意格式 =号两边不能有空格name_str=&quot;小关&quot;# 输出echo $name_str# 字符串拼接输出echo &quot;我的名字叫$name_str&quot;# 输出效果与 echo &quot;我的名字叫$name_str&quot; 相同 $&#123;变量&#125; 可以防止与接连的字符混淆echo &quot;我的名字叫$&#123;name_str&#125;&quot;# &apos; &apos; 符号内的变量，转移符将不生效，会输出 ： 我的名字叫$&#123;name_str&#125;echo &apos;我的名字叫$&#123;name_str&#125;&apos; 只读变量 变量名前 加上 readonly shell1234name_str=&quot;小关&quot;readonly name_strname_str=&quot;小燕&quot;;echo &quot;我的名字叫$&#123;name_str&#125;&quot;; 脚本运行结果,意思就是说，name_str 是只读变量 shell1./hello_shell.sh: line 2: name_str: readonly variable 删除变量 实例，删除变量后不可再次使用，unset不能删除readonly对象 shell12345678910name_str=&quot;小关&quot;;echo &quot;我的名字叫：$name_str&quot;## 删除变量unset name_str;echo &quot;我的名字叫：$&#123;name_str&#125;&quot;##name=&quot;小燕&quot;;readonly name;unset name;echo &quot;自读变量：$&#123;name&#125;&quot;; 运行结果 变量类型 局部变量，在shell脚步或者命令创建的变量，仅在当前shell实例有效。 环境变量，所有shell 脚本程序都可以有效访问。 shell变量，shell内置的系统变量。]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>脚本</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[001_Shell_环境]]></title>
    <url>%2F2017%2F01%2F01%2FShell%2F001_Shell_%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[序Shell Shell是一款使用C语言编写的程序，是用户使用Linux的桥梁。Shell是一种命令语言，又是一种程序设计语言。 Shell Script （Shell脚本） Shell Script 是一种由Shell编写的脚本程序。人们经常说的Shell通常指的是Shell Script ,但是你们要清楚Shell与Shell Script 是两种不同的概念。由于简洁起见，本文说的Shell编程指的是Shell Script 。 Shell 环境 Bourne Shell (/usr/bin/sh或者/bin/sh) Bourne Again Shell (/bin/bash) C Shell (/usr/bin/csh) K Shell (/usr/bin/ksh) Shell for Root (/sbin/sh) 现在很多Linux系统默认集成的是Bourne Again Shell,而且简单，免费。 在日常工作中被广泛使用。同时，Bash也是大多数Linux系统默认的Shell。 工具 1、使用文本编辑工具，如果是Linux 系统一般回使用vim来编辑（但是本人并不熟悉）,所以接下来我会使用Visual Studio Code 来编辑。 Hello Shell 创建 hello_Shell.sh 文件 Shell123456# 执行命令 创建shell文件vim hello_Shell.sh# hello_Shell.sh 内容#!/bin/bashecho &quot;Hello Shell !&quot; 执行脚本 shell1234567# 方法1sh hello_shell.sh#方法2## 先赋予执行权限chmod +x hello_shell.sh## 执行脚本./hello_shell.sh]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>脚本</tag>
        <tag>学习</tag>
      </tags>
  </entry>
</search>
