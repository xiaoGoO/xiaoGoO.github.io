[{"title":"架构模式之MVX","date":"2018-02-25T15:08:22.000Z","path":"2018/02/25/Structure/架构模式之MVX/","text":"MVX = &gt; MVC/MVP/MVVM 本文讲会介绍MVC,MVP,MVVM的区别和使用 MVC MVC模式最早是由Trygve Reenskaug在1978年提出的，是 帕罗奥多研究中心（Xerox PARC）在20世纪80年代为程序语言Smalltalk 发明的一种软件架构。MVC模式的目的是实现一种动态的程序设计，使后续对程序的修改和扩展简化，并且使程序某一部分的重复利用成为可能。除此之外，此模式通过对复杂度的简化，使程序结构更加直观 MVC模式 对于mvc模式很多程序员都清楚，但大部分的程序员都不知道的是MVC的概念其实不止一种，就算现在流行的mvvm,mvp也是由mvc变种而来。 早期MVC 早期的mvc模式可以简单的理解为： Model：根据用户的心理模型构建数据和数据的逻辑 View：负责呈现，将数据展现给用户 Controller：负责处理用户的指令，并且反馈给 Model和View 流程图： 标准MVC 怎么才算是标准的MVC，我现在还得不出结论。但是目前得到的资料都统一认同的一点就是。MVC分为 View、Controller、Model 三部分，而且这些组成的职责叙述也相同。 标准MVC的理解： Model: 管理应用的行为和数据，响应数据请求（经常来自视图）和更新状态的指令（经常来自控制器） View: 管理作为位图展示到屏幕上的图形和文字输出； 翻译用户的输入并依照用户的输入操作模型和视图； 流程图： IOS下的MVC模式 iOS 的 Cocoa Touch 框架一直采用MVC的设计模式，又因为IOS的页面是基于UIViewController 显示的，每个UIViewController下绑定一个根View。这使得控制层和UI层紧密的耦合在一起，这也是致使UIViewController一直很臃肿的原因之一 MVC核心 MVC最重要的是将原本杂乱的代码层级化，将原本杂乱的代码分为 展示层（View,Controller）和领域层(Model),在这时，领域层中的领域对象由于其自身特点不需要对展示层有任何了解，可以同时为不同的展示层工作。 MVP模式 根据维基百科中描述的MVP模式其实也是MVC的一个变种，其实MVP与MVC也是比较相像，其中最大的区别就是MVP使用Presenter对View和Model进行了解耦合。View与Model不直接通讯都是必须经过Presenter作为桥梁 mvp理解： Presenter: 包含UI的处理逻辑 负责与View和model通讯 Model: 数据和数据的处理逻辑，只能与Persenter通讯 View：负责呈现只能与Persenter通讯 图解： 特点： 降低View与Model的耦合，使代码更灵活。 但是同时的增加了Presenter 的压力使的为之厚重了许多。 MVP变种：被动视图（Passive View）被动视图顾名思义就是视图层完全处于被动，即：改模式下View自身不具备改变自身的任何方法，只负责展示视图的结构和内容，本身不具有任何的逻辑。所有的变化都是由Presenter改变。 图解 特点： 视图层完全处于被动，就是说视图成与Model层完全隔离，使得Model层与View层更加灵活，可以自由组合 相当于 MVP的进化版，冲而加重Presenter 的逻辑复杂性。 MVVM MVVM是马丁·福勒的PM（Presentation Model）设计模式的变体。 MVVM以相同的方式抽象出视图的状态和行为， 但PM以不依赖于特定用户界面平台的方式抽象出视图（创建了视图模型）。MVVM和PM都来自MVC模式。 MVVM组成 View 展现UI Model 数据模型 ViewModel 视图模型负责绑定控制视图，使之Model与View关联，同时降低耦合关系网MVVM 与MVP 很相像，唯一不同的就是 ViewModel 与 View 之间是采用双向绑定。其中一方有变动都会反映给对方。 MVVM前身PM（Presentation Model ）PM 模式将视图中的全部状态和行为放到一个单独的展示模型中，协调领域对象（模型）并且为视图层提供一个接口。在监督控制器中，视图层与模型层中的一些简单属性进行绑定，在模型属性变化时直接更新视图，而 PM 通过引入展示模型将模型层中的数据与复杂的业务逻辑封装成属性与简单的数据同时暴露给视图，让视图和展示模型中的属性进行同步。 总结无论哪种设计模式都有各自的优点，选择上还是根据自身的平台和项目的需求选择哪种设计模式。只要注意代码的臃肿和各模块之间的耦合性，写出整洁易懂的代码即可。 参考https://draveness.me/mvx 该文章是学习MVVM过程中顺便记录下的，本人表述能力比较低，有错误之处请指出谢谢。","tags":[]},{"title":"node.js版本管理","date":"2017-02-03T14:46:53.000Z","path":"2017/02/03/Node/node-js版本管理/","text":"使用nvm，管理node版本 因为是开源软件，所以具备大多数开源软件都存在的“版本问题”，版本发展很快，版本前后差异性大，老系统用新版本node跑不过，全局安装的第三方组件和node版本相关造成全局版本混乱 1. nvm主要特点 可安装多版本的node。 灵活切换当前的node版本。 以沙箱方式全局安装第三方组件到对应版本的node中。 通过.vnmrc文件，方便灵活地指定各应用系统所需的node版本进行运行 可惜目前只支持linux，OS系统。2. nvm安装12345678//使用 brew 安装 nvmbrew install nvm//其次需要在shell的配置文件~/.bash_profile (如果没有.bash_profile文件需要自行touch .bash_profile)中添加如下内容：# For NVMexport NVM_DIR=~/.nvmsource $(brew --prefix nvm)/nvm.sh//然后重新sourcesource .bash_profile 3. 使用nvm安装node12345678910//安装当前最新的稳定版。nvm install stable//安装指定版本nvm install 9.4.0//查看当前版本nvm current//切换node版本 nvm use 9//显示所有安装的版本nvm ls","tags":[{"name":"前端","slug":"前端","permalink":"https://xiaoGoO.github.io.git/tags/前端/"},{"name":"H5","slug":"H5","permalink":"https://xiaoGoO.github.io.git/tags/H5/"}]},{"title":"007_Shell_运算符","date":"2017-01-01T14:35:15.000Z","path":"2017/01/01/Shell/007-Shell-运算符/","text":"运算符 序 shell 支持多种运算符例如： 算术运算符 关系运算符 布尔运算符 字符串运算符 文件测试运算符 原生的bash不支持算数运算符，需要借助其他命令来完成，例如： awk expr(比较常用) expr 格式 1值=`expr 值1 运算符 值2` 注意: 表达式和运算符之间要有空格，例如 2+2 是不对的，必须写成 2 + 2，这与我们熟悉的大多数编程语言不一样。 完整的表达式要被 包含，注意这个字符不是常用的单引号，在 Esc 键下边。 所有运算符 运算符 | 说明 | 例子 — | — | — | 加 | expr 1 + 1 =&gt; 2 | 减 | expr 2 - 1 =&gt; 1 | 乘 | expr 2 \\* 2 =&gt; 4/ | 除 | expr 2 / 2 =&gt; 1% | 除余 | expr 2 % 2 =&gt; 0= | 赋值符 | a=$b 就是将变量b的值赋予给变量a== | 判断符，等于 | [ $a == $b ] 判断变量a是否等于变量b,如果相等返回true，否则false!= | 判断符，不等于 | [ $a != $b ] 与 == 相反","tags":[{"name":"脚本","slug":"脚本","permalink":"https://xiaoGoO.github.io.git/tags/脚本/"},{"name":"学习","slug":"学习","permalink":"https://xiaoGoO.github.io.git/tags/学习/"}]},{"title":"006_Shell_传参","date":"2017-01-01T14:33:47.000Z","path":"2017/01/01/Shell/006-Shell-传参/","text":"传参 序 我们在开发脚本过程中，少不了会给执行的脚步传递参数 ，就好比我写一个文件复制的脚步，我需要动态传递我需要复制的文件路径和复制后存放的路径，要不然没用一次就改一次代码就太不人性化了。 实例 比我写了个脚本名为：006_shell_params.sh shell123456#获取参数echo &quot;获取执行脚本名称：$0&quot;echo &quot;获取第一个参数：$1&quot;echo &quot;获取第二个参数：$2&quot;echo &quot;参数个数：$#&quot;echo &quot;全部参数：$*&quot; - 执行结果 ![参数结果](http://oiu3bjtd5.bkt.clouddn.com/20180305152021858543372.jpg) 参数处理表 处理 | 说明 — | — $# | 参数个数 $ | 以字符串的方式输出所有参数 , “$“ -&gt; “param0 param1 param2” $@ | 与$相同，但是用 **“*** 号括起来，是以数组形式输出 “$@” -&gt; “param0” “param1” “param2” $! | 运行最后一个进程的ID $- | 显示Shell的当前选项 $? | 显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。","tags":[{"name":"脚本","slug":"脚本","permalink":"https://xiaoGoO.github.io.git/tags/脚本/"},{"name":"学习","slug":"学习","permalink":"https://xiaoGoO.github.io.git/tags/学习/"}]},{"title":"005_Shell_注释","date":"2017-01-01T14:32:29.000Z","path":"2017/01/01/Shell/005-Shell-注释/","text":"注释 序 # 号后面的内容都会被注释 注释即脚本运行时不起作用的内容，知用于脚本代码说明。","tags":[{"name":"脚本","slug":"脚本","permalink":"https://xiaoGoO.github.io.git/tags/脚本/"},{"name":"学习","slug":"学习","permalink":"https://xiaoGoO.github.io.git/tags/学习/"}]},{"title":"004_Shell_数组","date":"2017-01-01T14:31:24.000Z","path":"2017/01/01/Shell/004-Shell-数组/","text":"数组 序 只支持一维数组 下标由0开始的数组 数组的定义 一般用括号“()” 来表示数组，每个元素用空格隔开 shell1234567891011121314# 变量名称=(元素0 元素1 元素2 ... 元素n-1)# 定义数组变量的方法有三种# 类型一array=(&quot;小关1号&quot; &quot;小关2号&quot; &quot;小关3号&quot;)#类型二array2=( &quot;小燕1号&quot; &quot;小燕2号&quot; &quot;小燕3号&quot;)#类型三array3[0]=&quot;xiaoG一号&quot;array3[1]=&quot;xiaoG二号&quot;array3[2]=&quot;xiaoG三号&quot; 读取数组 读取数组的格式为 ${数组[下标]} shell12345678910111213array=(&quot;小关1号&quot; &quot;小关2号&quot; &quot;小关3号&quot;)# 读取数组第一个值echo $&#123;array[0]&#125;# 读取数组所有元素echo $&#123;array[@]&#125;# 读取数组长度echo $&#123;#array[@]&#125;#或者echo $&#123;#array[*]&#125;#获取数组第n个元素的长度 echo $&#123;#array[n]&#125;","tags":[{"name":"脚本","slug":"脚本","permalink":"https://xiaoGoO.github.io.git/tags/脚本/"},{"name":"学习","slug":"学习","permalink":"https://xiaoGoO.github.io.git/tags/学习/"}]},{"title":"003_Shell_字符串","date":"2017-01-01T14:29:45.000Z","path":"2017/01/01/Shell/003-Shell-字符串/","text":"Shell 字符串 序 shell的数据类型就只有数字和字符串 单引号 作用 单引号里的内容回被原样输出，转义符、变量的作用将会失效。 例子 代码 shell12name=&apos;小关&apos;;echo &apos;我的名字叫$name&apos; 运行效果如下 双引号 作用 双引号里的转义符，变量会生效 例子 代码 shell12name=&apos;小关&apos;;echo &quot;我的名字叫$name&quot; 运行结果如下 拼接 例子 shell1234xiaoG=&quot;小关&quot;;xiaoY=&quot;小燕&quot;;newStr=&quot;$&#123;xiaoG&#125;+$&#123;xiaoY&#125;&quot;echo $newStr &quot;在一起&quot; 运行结果如下 长度 例子 shell123## 获取字符串长度 ###str=&quot;你猜我有多长？&quot;;echo &quot;你的长度是：$&#123;#str&#125;&quot; 运行结果 截取子串 例子 代码，截取子串的范围 ${str:1:2} -&gt; 截取变量 str 从第2个字符串开始截取长度未2 shell123## 截取子字符串 ##str=&quot;你截取“小关”试试看&quot;echo &quot;截取：$&#123;str:4:2&#125;&quot; 运行结果 查找子串的位置 例子 代码，查找子串“小关”的位置 shell1234## 查找子串位置 ##str=&quot;你看看“小关”在哪里？&quot;subStr=&quot;小关&quot;echo `expr index &quot;$str&quot; $subStr` 因为本人使用的事macos 系统，因为 macos系统使用的是BSD expr 不能执行该语句，Linux 使用的是 GNU expr 可以执行该语句","tags":[{"name":"脚本","slug":"脚本","permalink":"https://xiaoGoO.github.io.git/tags/脚本/"},{"name":"学习","slug":"学习","permalink":"https://xiaoGoO.github.io.git/tags/学习/"}]},{"title":"002_Shell_变量","date":"2017-01-01T13:02:30.000Z","path":"2017/01/01/Shell/002_Shell_变量/","text":"基本语法变量 变量命名规则 首个字符必须为字母（a-z，A-Z）。 中间不能有空格，可以使用下划线（_） 不能使用标点符号。 不能使用bash里的关键字（可用help命令查看保留关键字）。 变量的使用 Shell12345678910# 赋值 注意格式 =号两边不能有空格name_str=&quot;小关&quot;# 输出echo $name_str# 字符串拼接输出echo &quot;我的名字叫$name_str&quot;# 输出效果与 echo &quot;我的名字叫$name_str&quot; 相同 $&#123;变量&#125; 可以防止与接连的字符混淆echo &quot;我的名字叫$&#123;name_str&#125;&quot;# &apos; &apos; 符号内的变量，转移符将不生效，会输出 ： 我的名字叫$&#123;name_str&#125;echo &apos;我的名字叫$&#123;name_str&#125;&apos; 只读变量 变量名前 加上 readonly shell1234name_str=&quot;小关&quot;readonly name_strname_str=&quot;小燕&quot;;echo &quot;我的名字叫$&#123;name_str&#125;&quot;; 脚本运行结果,意思就是说，name_str 是只读变量 shell1./hello_shell.sh: line 2: name_str: readonly variable 删除变量 实例，删除变量后不可再次使用，unset不能删除readonly对象 shell12345678910name_str=&quot;小关&quot;;echo &quot;我的名字叫：$name_str&quot;## 删除变量unset name_str;echo &quot;我的名字叫：$&#123;name_str&#125;&quot;##name=&quot;小燕&quot;;readonly name;unset name;echo &quot;自读变量：$&#123;name&#125;&quot;; 运行结果 变量类型 局部变量，在shell脚步或者命令创建的变量，仅在当前shell实例有效。 环境变量，所有shell 脚本程序都可以有效访问。 shell变量，shell内置的系统变量。","tags":[{"name":"脚本","slug":"脚本","permalink":"https://xiaoGoO.github.io.git/tags/脚本/"},{"name":"学习","slug":"学习","permalink":"https://xiaoGoO.github.io.git/tags/学习/"}]},{"title":"001_Shell_环境","date":"2017-01-01T13:02:25.000Z","path":"2017/01/01/Shell/001_Shell_环境/","text":"序Shell Shell是一款使用C语言编写的程序，是用户使用Linux的桥梁。Shell是一种命令语言，又是一种程序设计语言。 Shell Script （Shell脚本） Shell Script 是一种由Shell编写的脚本程序。人们经常说的Shell通常指的是Shell Script ,但是你们要清楚Shell与Shell Script 是两种不同的概念。由于简洁起见，本文说的Shell编程指的是Shell Script 。 Shell 环境 Bourne Shell (/usr/bin/sh或者/bin/sh) Bourne Again Shell (/bin/bash) C Shell (/usr/bin/csh) K Shell (/usr/bin/ksh) Shell for Root (/sbin/sh) 现在很多Linux系统默认集成的是Bourne Again Shell,而且简单，免费。 在日常工作中被广泛使用。同时，Bash也是大多数Linux系统默认的Shell。 工具 1、使用文本编辑工具，如果是Linux 系统一般回使用vim来编辑（但是本人并不熟悉）,所以接下来我会使用Visual Studio Code 来编辑。 Hello Shell 创建 hello_Shell.sh 文件 Shell123456# 执行命令 创建shell文件vim hello_Shell.sh# hello_Shell.sh 内容#!/bin/bashecho &quot;Hello Shell !&quot; 执行脚本 shell1234567# 方法1sh hello_shell.sh#方法2## 先赋予执行权限chmod +x hello_shell.sh## 执行脚本./hello_shell.sh","tags":[{"name":"脚本","slug":"脚本","permalink":"https://xiaoGoO.github.io.git/tags/脚本/"},{"name":"学习","slug":"学习","permalink":"https://xiaoGoO.github.io.git/tags/学习/"}]}]